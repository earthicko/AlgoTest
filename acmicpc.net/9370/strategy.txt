케이스 개수: T
교차로 수, 도로 수, 목적지 후보 수: n ~ 2000, m ~ 50000, t ~ 100
출발지, 지나간 교차로 1 2: s, g, h ~ n
a와 b 사이 거리 d (m개)
후보 x (t개)

T
n m t
s g h
a0 b0 d0
a1 b1 d1
...
am-1 bm-1 dm-1
x0
x1
...
xt-1

케이스 당 30ms, 최악 경우 400,000,000번 계산

케이스 수 int
목적지 수 int
목적지 배열 int[100]
방문 완료한 목적지 수 int
가능한 목적지 배열 int[100]
지나간 교차로 배열 int[2]
출발지 int
우선 순위 큐 (노드 번호 int, 거리 int), 거리 따라 정렬
노드 수 int
거리 정보 배열 int[2000][2000] ~ 32MB
방문 여부 배열 int[2000] ~ 16KB
최단 거리 배열 int[2000] ~ 16KB
이전 방문한 노드 번호 배열 int[2000] ~ 16KB

1. 출발점으로부터의 최단거리를 저장할 배열 d[v]를 만들고, 출발 노드에는 0을, 출발점을 제외한 다른 노드들에는 매우 큰 값 INF를 채워 넣는다. 
2. 현재 노드를 나타내는 변수 A에 출발 노드의 번호를 저장한다.
3. A로부터 갈 수 있는 임의의 노드 B에 대해, d[A] + P[A][B]와 d[B]의 값을 비교한다. INF와 비교할 경우 무조건 전자가 작다.
4. 만약 d[A] + P[A][B]의 값이 더 작다면, 즉 더 짧은 경로라면, d[B]의 값을 이 값으로 갱신시킨다.
5. A의 모든 이웃 노드 B에 대해 이 작업을 수행한다.
6. A의 상태를 "방문 완료"로 바꾼다. 그러면 이제 더 이상 A는 사용하지 않는다.
7. "미방문" 상태인 모든 노드들 중, 출발점으로부터의 거리가 제일 짧은 노드 하나를 골라서 그 노드를 A에 저장한다.
8. 도착 노드가 "방문 완료" 상태가 되거나, 혹은 더 이상 미방문 상태의 노드를 선택할 수 없을 때까지, 3~7의 과정을 반복한다.
이 작업을 마친 뒤, 도착 노드에 저장된 값이 바로 A로부터의 최단 거리이다. 만약 이 값이 INF라면, 중간에 길이 끊긴 것임을 의미한다.

도착 노드 중 하나가 방문 완료 상태 될 시 경로 추적, "지나간 교차로" 검출 시 가능한 목적지 배열에 추가

N_CASES <= 100
N_DEST <= 100
N_VISITED_DEST <= 100
N_POSSIBLE_DEST <= 100
START <= 2000
DEST[100] <= 2000           0 ~ 99
POSSIBLE_DEST[100] <= 2000  0 ~ 99
TRACE[2] <= 2000            0 ~ 1
N_NODES <= 2000
N_TOTAL_ROADS <= 50000
N_ROADS[2001] <= 1999       1 ~ 2000
ROADS[2001][2001] <= 2000   1 ~ 2000, 0 ~ 1999
D[2001][2001] <= 1000       1 ~ 2000
VISITED[2001] <= 1          1 ~ 2000
MIN_D[2001] <= 2,000,000    1 ~ 2000
PREV[2001] <= 2000          1 ~ 2000